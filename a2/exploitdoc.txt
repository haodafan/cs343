Exploit 3: The string one that took me 10 years to get right and made me prematurely bald

In the string format exploit, we take advantage of several string format options in C's printf function. 

The cornerstone of our attack is "%n" which writes the number of bytes we printed thus far in the string to the variables that come after the string in the printf parameters. 

So similar to our previous overflowy attacks, we shall use this "%n" to rewrite the return address and direct it to our premade shellcode. 

First off, we will need to control where %n writes to. Normally %n writes to the variables proceeding the its containing string, however if printf does not have any actual arguments after the string, %n will just write to whatever address is there. We can control this address by padding the length of the string before %n. 

So how much should we pad? We can figure it out using gdb and another string format exploit. %x will display whatever data is in the address at that location. We can enter into the printf a string with "AAAA" and add a long list of "%x"s afterwards. Then, we can inspect the output to see how many "%x"s we need before it displays 0x41414141 (which tells us that the %x at that location points to the "AAAA"). Once we figure this out, we replace the "%x" at that location with our desired "%n". 

So now we have a %n which will write to what it thinks is the address of a variable but really is the beginning part of our string. So instead of having "AAAA" there, we replace it with the address of our EIP. (which we can find out using gdb).

So how do we write the address of our malicious code into that EIP? We know %n writes the number of characters before %n into the address ... so ... what if we had a string with the length equal to the address of our malicious code?! (GENIUS :O )